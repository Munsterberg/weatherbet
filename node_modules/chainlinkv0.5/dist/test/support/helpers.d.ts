/// <reference types="node" />
import { BN } from 'bn.js';
import { FunctionFragment, ParamType } from 'ethers/utils/abi-coder';
export declare const eth: any;
export declare let accounts: any, defaultAccount: any, oracleNode1: any, oracleNode2: any, oracleNode3: any, stranger: any, consumer: any, oracleNode: any;
export declare const personas: Record<string, any>;
export declare const BNtoUint8Array: (n: any) => Uint8Array;
export declare const wrappedERC20: (contract: any) => any;
export declare const linkContract: (account: any) => Promise<any>;
export declare const bigNum: any;
export declare const toWei: (num: string | number) => any;
export declare const toUtf8: any;
export declare const keccak: any;
export declare const hexToInt: (str: string) => any;
export declare const toHexWithoutPrefix: (arg: any) => string;
export declare const toHex: (value: any) => string;
export declare function Ox(value: any): string;
export declare const isByteRepresentation: (h: any) => boolean;
export declare const getEvents: (contract: any) => Promise<any[]>;
export declare const getLatestEvent: (contract: any) => Promise<any[]>;
export declare const requestDataFrom: (oc: any, link: any, amount: any, args: any, options: any) => any;
export declare const getMethod: (contract: any, methodName: string) => FunctionFragment;
export declare const functionSelector: any;
export declare const functionSelectorFromAbi: (contract: any, name: string) => string;
export declare const assertActionThrows: (action: any, messageContains?: RegExp) => Promise<void>;
export declare const checkPublicABI: (contract: any, expectedPublic: any) => void;
export declare const decodeRunABI: (log: any) => any;
export declare const decodeRunRequest: (log: any) => any;
export declare const decodeDietCBOR: (data: any) => any;
export declare const runRequestId: (log: any) => any;
export declare const requestDataBytes: (specId: any, to: any, fHash: any, nonce: any, data: any) => any;
export declare function abiEncode(types: any, values: any): string;
export declare const newUint8ArrayFromStr: (str: string) => Uint8Array;
export declare const newUint8ArrayFromHex: (str: string, count: number) => Uint8Array;
export declare const newUint8ArrayFromDecimal: (str: string, count: number) => any;
export declare const newSignature: (str: string) => any;
/**
 * @param str hexadecimal/decimal representation of integer. 0x must prefix hex.
 * @returns 32-byte representation of number. If hexadecimal, zero-padded on
 *          the right. If decimal, zero-padded on the left.
 * @todo (alx): Split this into more specific and explicit functions.
 */
export declare const newHash: (str: string) => Uint8Array;
export declare const newAddress: (str: string) => Uint8Array;
export declare const newSelector: (str: string) => Uint8Array;
export declare const toBuffer: (uint8a: Uint8Array) => Buffer;
export declare const concatUint8Arrays: (...arrays: Uint8Array[]) => Uint8Array;
export declare const increaseTime5Minutes: () => Promise<void>;
export declare const sendToEvm: (evmMethod: string, ...params: any) => Promise<void>;
export declare const mineBlocks: (blocks: number) => Promise<void>;
export declare const createTxData: (selector: string, types: any, values: any) => any;
interface Signature {
    v: number;
    r: Uint8Array;
    s: Uint8Array;
}
interface ServiceAgreement {
    payment: BN;
    expiration: BN;
    endAt: BN;
    oracles: string[];
    requestDigest: string;
    aggregator: string;
    aggInitiateJobSelector: string;
    aggFulfillSelector: string;
    id: string;
    oracleSignatures: Signature[];
}
export declare const generateSAID: (sa: ServiceAgreement) => Uint8Array;
export declare const recoverPersonalSignature: (message: Uint8Array, signature: Signature) => any;
export declare const personalSign: (account: any, message: any) => Promise<any>;
export declare const executeServiceAgreementBytes: (sAID: any, callbackAddr: any, callbackFunctionId: any, nonce: any, data: any) => any;
export declare const depositFundsBytes: (to: string, amount: number) => string;
export declare const strip0x: (s: string) => string;
export declare const padHexTo256Bit: (s: string) => string;
export declare function pad0xHexTo256Bit(s: string): string;
export declare const padNumTo256Bit: (n: number) => string;
export declare const constructStructArgs: (fieldNames: string[], values: any[]) => any[];
export declare const structAsTuple: (struct: {
    [fieldName: string]: any;
}, contract: any, methodName: string, argName: string) => {
    abi: ParamType;
    struct: ArrayLike<any>;
};
export declare const initiateServiceAgreementArgs: (coordinator: any, serviceAgreement: ServiceAgreement) => any[];
export declare const initiateServiceAgreementCall: (coordinator: any, serviceAgreement: ServiceAgreement) => Promise<any>;
/** Call coordinator contract to initiate the specified service agreement. */
export declare const initiateServiceAgreement: (coordinator: any, serviceAgreement: ServiceAgreement) => Promise<any>;
/** Check that the given service agreement was stored at the correct location */
export declare const checkServiceAgreementPresent: (coordinator: any, serviceAgreement: ServiceAgreement) => Promise<void>;
export declare const checkServiceAgreementAbsent: (coordinator: any, serviceAgreementID: any) => Promise<void>;
export declare const newServiceAgreement: (params: Partial<ServiceAgreement>) => Promise<ServiceAgreement>;
export declare function sixMonthsFromNow(): number;
export declare const fulfillOracleRequest: (oracle: any, request: any, response: any, options: any) => Promise<any>;
export declare const cancelOracleRequest: (oracle: any, request: any, options: any) => Promise<any>;
export declare const hexPadUint256: (n: any) => string;
export declare const encodeUint256: (int: any) => string;
export declare const encodeInt256: (int: any) => string;
export declare const encodeAddress: (a: string) => string;
export {};
