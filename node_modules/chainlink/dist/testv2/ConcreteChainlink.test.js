"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const h = __importStar(require("../src/helpersV2"));
const ConcreteChainlinkFactory_1 = require("../src/generated/ConcreteChainlinkFactory");
const ethers_1 = require("ethers");
const chai_1 = require("chai");
const debug_1 = require("../src/debug");
const ganache_core_1 = __importDefault(require("ganache-core"));
const provider = new ethers_1.ethers.providers.Web3Provider(ganache_core_1.default.provider());
const concreteChainlinkFactory = new ConcreteChainlinkFactory_1.ConcreteChainlinkFactory();
const debug = debug_1.makeDebug('ConcreteChainlink');
describe('ConcreteChainlink', () => {
    let ccl;
    let defaultAccount;
    const deployment = h.useSnapshot(provider, async () => {
        defaultAccount = await h
            .initializeRolesAndPersonas(provider)
            .then(r => r.roles.defaultAccount);
        ccl = await concreteChainlinkFactory.connect(defaultAccount).deploy();
    });
    beforeEach(async () => {
        await deployment();
    });
    it('has a limited public interface', () => {
        h.checkPublicABI(concreteChainlinkFactory, [
            'add',
            'addBytes',
            'addInt',
            'addStringArray',
            'addUint',
            'closeEvent',
            'setBuffer',
        ]);
    });
    async function parseCCLEvent(tx) {
        const receipt = await tx.wait();
        const data = receipt.logs[0].data;
        const d = debug.extend('parseCCLEvent');
        d('data %s', data);
        return ethers_1.ethers.utils.defaultAbiCoder.decode(['bytes'], data);
    }
    describe('#close', () => {
        it('handles empty payloads', async () => {
            const tx = await ccl.closeEvent();
            const [payload] = await parseCCLEvent(tx);
            const decoded = await h.decodeDietCBOR(payload);
            chai_1.assert.deepEqual(decoded, {});
        });
    });
    describe('#setBuffer', () => {
        it('emits the buffer', async () => {
            await ccl.setBuffer('0xA161616162');
            const tx = await ccl.closeEvent();
            const [payload] = await parseCCLEvent(tx);
            const decoded = await h.decodeDietCBOR(payload);
            chai_1.assert.deepEqual(decoded, { a: 'b' });
        });
    });
    describe('#add', () => {
        it('stores and logs keys and values', async () => {
            await ccl.add('first', 'word!!');
            const tx = await ccl.closeEvent();
            const [payload] = await parseCCLEvent(tx);
            const decoded = await h.decodeDietCBOR(payload);
            chai_1.assert.deepEqual(decoded, { first: 'word!!' });
        });
        it('handles two entries', async () => {
            await ccl.add('first', 'uno');
            await ccl.add('second', 'dos');
            const tx = await ccl.closeEvent();
            const [payload] = await parseCCLEvent(tx);
            const decoded = await h.decodeDietCBOR(payload);
            chai_1.assert.deepEqual(decoded, {
                first: 'uno',
                second: 'dos',
            });
        });
    });
    describe('#addBytes', () => {
        it('stores and logs keys and values', async () => {
            await ccl.addBytes('first', '0xaabbccddeeff');
            const tx = await ccl.closeEvent();
            const [payload] = await parseCCLEvent(tx);
            const decoded = await h.decodeDietCBOR(payload);
            const expected = h.hexToBuf('0xaabbccddeeff');
            chai_1.assert.deepEqual(decoded, { first: expected });
        });
        it('handles two entries', async () => {
            await ccl.addBytes('first', '0x756E6F');
            await ccl.addBytes('second', '0x646F73');
            const tx = await ccl.closeEvent();
            const [payload] = await parseCCLEvent(tx);
            const decoded = await h.decodeDietCBOR(payload);
            const expectedFirst = h.hexToBuf('0x756E6F');
            const expectedSecond = h.hexToBuf('0x646F73');
            chai_1.assert.deepEqual(decoded, {
                first: expectedFirst,
                second: expectedSecond,
            });
        });
        it('handles strings', async () => {
            await ccl.addBytes('first', ethers_1.ethers.utils.toUtf8Bytes('apple'));
            const tx = await ccl.closeEvent();
            const [payload] = await parseCCLEvent(tx);
            const decoded = await h.decodeDietCBOR(payload);
            const expected = ethers_1.ethers.utils.toUtf8Bytes('apple');
            chai_1.assert.deepEqual(decoded, { first: expected });
        });
    });
    describe('#addInt', () => {
        it('stores and logs keys and values', async () => {
            await ccl.addInt('first', 1);
            const tx = await ccl.closeEvent();
            const [payload] = await parseCCLEvent(tx);
            const decoded = await h.decodeDietCBOR(payload);
            chai_1.assert.deepEqual(decoded, { first: 1 });
        });
        it('handles two entries', async () => {
            await ccl.addInt('first', 1);
            await ccl.addInt('second', 2);
            const tx = await ccl.closeEvent();
            const [payload] = await parseCCLEvent(tx);
            const decoded = await h.decodeDietCBOR(payload);
            chai_1.assert.deepEqual(decoded, {
                first: 1,
                second: 2,
            });
        });
    });
    describe('#addUint', () => {
        it('stores and logs keys and values', async () => {
            await ccl.addUint('first', 1);
            const tx = await ccl.closeEvent();
            const [payload] = await parseCCLEvent(tx);
            const decoded = await h.decodeDietCBOR(payload);
            chai_1.assert.deepEqual(decoded, { first: 1 });
        });
        it('handles two entries', async () => {
            await ccl.addUint('first', 1);
            await ccl.addUint('second', 2);
            const tx = await ccl.closeEvent();
            const [payload] = await parseCCLEvent(tx);
            const decoded = await h.decodeDietCBOR(payload);
            chai_1.assert.deepEqual(decoded, {
                first: 1,
                second: 2,
            });
        });
    });
    describe('#addStringArray', () => {
        it('stores and logs keys and values', async () => {
            await ccl.addStringArray('word', [
                ethers_1.ethers.utils.formatBytes32String('seinfeld'),
                ethers_1.ethers.utils.formatBytes32String('"4"'),
                ethers_1.ethers.utils.formatBytes32String('LIFE'),
            ]);
            const tx = await ccl.closeEvent();
            const [payload] = await parseCCLEvent(tx);
            const decoded = await h.decodeDietCBOR(payload);
            chai_1.assert.deepEqual(decoded, { word: ['seinfeld', '"4"', 'LIFE'] });
        });
    });
});
//# sourceMappingURL=ConcreteChainlink.test.js.map