"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const cbor_1 = __importDefault(require("cbor"));
const h = __importStar(require("../src/helpersV2"));
const matchersV2_1 = require("../src/matchersV2");
const ethers_1 = require("ethers");
const chai_1 = require("chai");
const LinkTokenFactory_1 = require("../src/generated/LinkTokenFactory");
const OracleFactory_1 = require("../src/generated/OracleFactory");
const BasicConsumerFactory_1 = require("../src/generated/BasicConsumerFactory");
const ganache_core_1 = __importDefault(require("ganache-core"));
const basicConsumerFactory = new BasicConsumerFactory_1.BasicConsumerFactory();
const oracleFactory = new OracleFactory_1.OracleFactory();
const linkTokenFactory = new LinkTokenFactory_1.LinkTokenFactory();
// create ethers provider from that web3js instance
const provider = new ethers_1.ethers.providers.Web3Provider(ganache_core_1.default.provider());
let roles;
beforeAll(async () => {
    const rolesAndPersonas = await h.initializeRolesAndPersonas(provider);
    roles = rolesAndPersonas.roles;
});
describe('BasicConsumer', () => {
    const specId = '0x4c7b7ffb66b344fbaa64995af81e355a'.padEnd(66, '0');
    const currency = 'USD';
    let link;
    let oc;
    let cc;
    const deployment = h.useSnapshot(provider, async () => {
        link = await linkTokenFactory.connect(roles.defaultAccount).deploy();
        oc = await oracleFactory.connect(roles.oracleNode).deploy(link.address);
        cc = await basicConsumerFactory
            .connect(roles.defaultAccount)
            .deploy(link.address, oc.address, specId);
    });
    beforeEach(async () => {
        await deployment();
    });
    it('has a predictable gas price', async () => {
        const rec = await provider.getTransactionReceipt(cc.deployTransaction.hash);
        chai_1.assert.isBelow(rec.gasUsed.toNumber(), 1700000);
    });
    describe('#requestEthereumPrice', () => {
        describe('without LINK', () => {
            it('reverts', async () => {
                await h.assertActionThrows(async () => {
                    await cc.requestEthereumPrice(currency);
                });
            });
        });
        describe('with LINK', () => {
            beforeEach(async () => {
                await link.transfer(cc.address, ethers_1.ethers.utils.parseEther('1'));
            });
            it('triggers a log event in the Oracle contract', async () => {
                const tx = await cc.requestEthereumPrice(currency);
                const receipt = await tx.wait();
                const log = receipt.logs[3];
                chai_1.assert.equal(log.address, oc.address);
                const request = h.decodeRunRequest(log);
                const expected = {
                    path: ['USD'],
                    get: 'https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD,EUR,JPY',
                };
                chai_1.assert.equal(h.toHex(specId), request.jobId);
                matchersV2_1.assertBigNum(h.toWei('1'), request.payment);
                chai_1.assert.equal(cc.address, request.requester);
                chai_1.assert.equal(1, request.dataVersion);
                chai_1.assert.deepEqual(expected, cbor_1.default.decodeFirstSync(request.data));
            });
            it('has a reasonable gas cost', async () => {
                const tx = await cc.requestEthereumPrice(currency);
                const receipt = await tx.wait();
                chai_1.assert.isBelow(receipt.gasUsed.toNumber(), 120000);
            });
        });
    });
    describe('#fulfillOracleRequest', () => {
        const response = ethers_1.ethers.utils.formatBytes32String('1,000,000.00');
        let request;
        beforeEach(async () => {
            await link.transfer(cc.address, h.toWei('1'));
            const tx = await cc.requestEthereumPrice(currency);
            const receipt = await tx.wait();
            request = h.decodeRunRequest(receipt.logs[3]);
        });
        it('records the data given to it by the oracle', async () => {
            await h.fulfillOracleRequest(oc.connect(roles.oracleNode), request, response);
            const currentPrice = await cc.currentPrice();
            chai_1.assert.equal(currentPrice, response);
        });
        it('logs the data given to it by the oracle', async () => {
            const tx = await h.fulfillOracleRequest(oc.connect(roles.oracleNode), request, response);
            const receipt = await tx.wait();
            chai_1.assert.equal(2, receipt.logs.length);
            const log = receipt.logs[1];
            chai_1.assert.equal(log.topics[2], response);
        });
        describe('when the consumer does not recognize the request ID', () => {
            let otherRequest;
            beforeEach(async () => {
                const funcSig = ethers_1.ethers.utils
                    .id('fulfill(bytes32,bytes32)')
                    .slice(2)
                    .slice(0, 8);
                const args = h.requestDataBytes(specId, cc.address, `0x${funcSig}`, 43, '0x0');
                const tx = await h.requestDataFrom(oc, link, 0, args);
                const receipt = await tx.wait();
                otherRequest = h.decodeRunRequest(receipt.logs[2]);
            });
            it('does not accept the data provided', async () => {
                await h.fulfillOracleRequest(oc.connect(roles.oracleNode), otherRequest, response);
                const received = await cc.currentPrice();
                chai_1.assert.equal(ethers_1.ethers.utils.parseBytes32String(received), '');
            });
        });
        describe('when called by anyone other than the oracle contract', () => {
            it('does not accept the data provided', async () => {
                await h.assertActionThrows(async () => {
                    await cc.connect(roles.oracleNode).fulfill(request.id, response);
                });
                const received = await cc.currentPrice();
                chai_1.assert.equal(ethers_1.ethers.utils.parseBytes32String(received), '');
            });
        });
    });
    describe('#cancelRequest', () => {
        const depositAmount = h.toWei('1');
        let request;
        beforeEach(async () => {
            await link.transfer(cc.address, depositAmount);
            const tx = await cc.requestEthereumPrice(currency);
            const receipt = await tx.wait();
            request = h.decodeRunRequest(receipt.logs[3]);
        });
        describe('before 5 minutes', () => {
            it('cant cancel the request', async () => {
                await h.assertActionThrows(async () => {
                    await cc
                        .connect(roles.consumer)
                        .cancelRequest(request.id, request.payment, request.callbackFunc, request.expiration);
                });
            });
        });
        describe('after 5 minutes', () => {
            it('can cancel the request', async () => {
                await h.increaseTime5Minutes(provider);
                await cc
                    .connect(roles.consumer)
                    .cancelRequest(request.id, request.payment, request.callbackFunc, request.expiration);
            });
        });
    });
    describe('#withdrawLink', () => {
        const depositAmount = h.toWei('1');
        beforeEach(async () => {
            await link.transfer(cc.address, depositAmount);
            const balance = await link.balanceOf(cc.address);
            matchersV2_1.assertBigNum(balance, depositAmount);
        });
        it('transfers LINK out of the contract', async () => {
            await cc.connect(roles.consumer).withdrawLink();
            const ccBalance = await link.balanceOf(cc.address);
            const consumerBalance = ethers_1.ethers.utils.bigNumberify(await link.balanceOf(roles.consumer.address));
            matchersV2_1.assertBigNum(ccBalance, 0);
            matchersV2_1.assertBigNum(consumerBalance, depositAmount);
        });
    });
});
//# sourceMappingURL=BasicConsumer.test.js.map