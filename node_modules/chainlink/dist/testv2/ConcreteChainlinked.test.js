"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const h = __importStar(require("../src/helpersV2"));
const GetterSetterFactory_1 = require("../src/generated/GetterSetterFactory");
const EmptyOracleFactory_1 = require("../src/generated/EmptyOracleFactory");
const OracleFactory_1 = require("../src/generated/OracleFactory");
const ConcreteChainlinkedFactory_1 = require("../src/generated/ConcreteChainlinkedFactory");
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const LinkTokenFactory_1 = require("../src/generated/LinkTokenFactory");
const ganache_core_1 = __importDefault(require("ganache-core"));
const concreteChainlinkedFactory = new ConcreteChainlinkedFactory_1.ConcreteChainlinkedFactory();
const emptyOracleFactory = new EmptyOracleFactory_1.EmptyOracleFactory();
const getterSetterFactory = new GetterSetterFactory_1.GetterSetterFactory();
const oracleFactory = new OracleFactory_1.OracleFactory();
const linkTokenFactory = new LinkTokenFactory_1.LinkTokenFactory();
const provider = new ethers_1.ethers.providers.Web3Provider(ganache_core_1.default.provider());
let roles;
beforeAll(async () => {
    const rolesAndPersonas = await h.initializeRolesAndPersonas(provider);
    roles = rolesAndPersonas.roles;
});
describe('ConcreteChainlinked', () => {
    const specId = '0x4c7b7ffb66b344fbaa64995af81e355a00000000000000000000000000000000';
    let cc;
    let gs;
    let oc;
    let newoc;
    let link;
    const deployment = h.useSnapshot(provider, async () => {
        link = await linkTokenFactory.connect(roles.defaultAccount).deploy();
        oc = await oracleFactory.connect(roles.defaultAccount).deploy(link.address);
        newoc = await oracleFactory
            .connect(roles.defaultAccount)
            .deploy(link.address);
        gs = await getterSetterFactory.connect(roles.defaultAccount).deploy();
        cc = await concreteChainlinkedFactory
            .connect(roles.defaultAccount)
            .deploy(link.address, oc.address);
    });
    beforeEach(async () => {
        await deployment();
    });
    describe('#newRequest', () => {
        it('forwards the information to the oracle contract through the link token', async () => {
            const tx = await cc.publicNewRequest(specId, gs.address, ethers_1.ethers.utils.toUtf8Bytes('requestedBytes32(bytes32,bytes32)'));
            const receipt = await tx.wait();
            chai_1.assert.equal(1, receipt.logs.length);
            const [jId, cbAddr, cbFId, cborData] = h.decodeRunABI(receipt.logs[0]);
            const params = h.decodeDietCBOR(cborData);
            chai_1.assert.equal(specId, jId);
            chai_1.assert.equal(gs.address, cbAddr);
            chai_1.assert.equal('0xed53e511', cbFId);
            chai_1.assert.deepEqual({}, params);
        });
    });
    describe('#chainlinkRequest(Request)', () => {
        it('emits an event from the contract showing the run ID', async () => {
            const tx = await cc.publicRequest(specId, cc.address, ethers_1.ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'), 0);
            const { events, logs } = await tx.wait();
            chai_1.assert.equal(4, events.length);
            chai_1.assert.equal(logs[0].address, cc.address);
            chai_1.assert.equal(events[0].event, 'ChainlinkRequested');
        });
    });
    describe('#chainlinkRequestTo(Request)', () => {
        it('emits an event from the contract showing the run ID', async () => {
            const tx = await cc.publicRequestRunTo(newoc.address, specId, cc.address, ethers_1.ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'), 0);
            const { events } = await tx.wait();
            chai_1.assert.equal(4, events.length);
            chai_1.assert.equal(events[0].event, 'ChainlinkRequested');
        });
        it('emits an event on the target oracle contract', async () => {
            const tx = await cc.publicRequestRunTo(newoc.address, specId, cc.address, ethers_1.ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'), 0);
            const { logs } = await tx.wait();
            const event = newoc.interface.parseLog(logs[3]);
            chai_1.assert.equal(4, logs.length);
            chai_1.assert.equal(event.name, 'OracleRequest');
        });
        it('does not modify the stored oracle address', async () => {
            await cc.publicRequestRunTo(newoc.address, specId, cc.address, ethers_1.ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'), 0);
            const actualOracleAddress = await cc.publicOracleAddress();
            chai_1.assert.equal(oc.address, actualOracleAddress);
        });
    });
    describe('#cancelChainlinkRequest', () => {
        let requestId;
        // a concrete chainlink attached to an empty oracle
        let ecc;
        beforeEach(async () => {
            const emptyOracle = await emptyOracleFactory
                .connect(roles.defaultAccount)
                .deploy();
            ecc = await concreteChainlinkedFactory
                .connect(roles.defaultAccount)
                .deploy(link.address, emptyOracle.address);
            const tx = await ecc.publicRequest(specId, ecc.address, ethers_1.ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'), 0);
            const { events } = await tx.wait();
            requestId = events[0].args.id;
        });
        it('emits an event from the contract showing the run was cancelled', async () => {
            const tx = await ecc.publicCancelRequest(requestId, 0, ethers_1.ethers.utils.hexZeroPad('0x', 4), 0);
            const { events } = await tx.wait();
            chai_1.assert.equal(1, events.length);
            chai_1.assert.equal(events[0].event, 'ChainlinkCancelled');
            chai_1.assert.equal(requestId, events[0].args.id);
        });
        it('throws if given a bogus event ID', async () => {
            await h.assertActionThrows(async () => {
                await ecc.publicCancelRequest(ethers_1.ethers.utils.formatBytes32String('bogusId'), 0, ethers_1.ethers.utils.hexZeroPad('0x', 4), 0);
            });
        });
    });
    describe('#recordChainlinkFulfillment(modifier)', () => {
        let request;
        beforeEach(async () => {
            const tx = await cc.publicRequest(specId, cc.address, ethers_1.ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'), 0);
            const { logs } = await tx.wait();
            request = h.decodeRunRequest(logs[3]);
        });
        it('emits an event marking the request fulfilled', async () => {
            const tx = await h.fulfillOracleRequest(oc, request, ethers_1.ethers.utils.formatBytes32String('hi mom!'));
            const { logs } = await tx.wait();
            const event = cc.interface.parseLog(logs[0]);
            chai_1.assert.equal(1, logs.length);
            chai_1.assert.equal(event.name, 'ChainlinkFulfilled');
            chai_1.assert.equal(request.id, event.values.id);
        });
    });
    describe('#fulfillChainlinkRequest(function)', () => {
        let request;
        beforeEach(async () => {
            const tx = await cc.publicRequest(specId, cc.address, ethers_1.ethers.utils.toUtf8Bytes('publicFulfillChainlinkRequest(bytes32,bytes32)'), 0);
            const { logs } = await tx.wait();
            request = h.decodeRunRequest(logs[3]);
        });
        it('emits an event marking the request fulfilled', async () => {
            const tx = await h.fulfillOracleRequest(oc, request, ethers_1.ethers.utils.formatBytes32String('hi mom!'));
            const { logs } = await tx.wait();
            const event = cc.interface.parseLog(logs[0]);
            chai_1.assert.equal(1, logs.length);
            chai_1.assert.equal(event.name, 'ChainlinkFulfilled');
            chai_1.assert.equal(request.id, event.values.id);
        });
    });
    describe('#chainlinkToken', () => {
        it('returns the Link Token address', async () => {
            const addr = await cc.publicChainlinkToken();
            chai_1.assert.equal(addr, link.address);
        });
    });
    describe('#addExternalRequest', () => {
        let mock;
        let request;
        beforeEach(async () => {
            mock = await concreteChainlinkedFactory
                .connect(roles.defaultAccount)
                .deploy(link.address, oc.address);
            const tx = await cc.publicRequest(specId, mock.address, ethers_1.ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'), 0);
            const receipt = await tx.wait();
            request = h.decodeRunRequest(receipt.logs[3]);
            await mock.publicAddExternalRequest(oc.address, request.id);
        });
        it('allows the external request to be fulfilled', async () => {
            await h.fulfillOracleRequest(oc, request, ethers_1.ethers.utils.formatBytes32String('hi mom!'));
        });
        it('does not allow the same requestId to be used', async () => {
            await h.assertActionThrows(async () => {
                await cc.publicAddExternalRequest(newoc.address, request.id);
            });
        });
    });
});
//# sourceMappingURL=ConcreteChainlinked.test.js.map