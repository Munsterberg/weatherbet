"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const h = __importStar(require("../src/helpersV2"));
const matchersV2_1 = require("../src/matchersV2");
const ENSRegistryFactory_1 = require("../src/generated/ENSRegistryFactory");
const PublicResolverFactory_1 = require("../src/generated/PublicResolverFactory");
const UpdatableConsumerFactory_1 = require("../src/generated/UpdatableConsumerFactory");
const ethers_1 = require("ethers");
const chai_1 = require("chai");
const LinkTokenFactory_1 = require("../src/generated/LinkTokenFactory");
const OracleFactory_1 = require("../src/generated/OracleFactory");
const ganache_core_1 = __importDefault(require("ganache-core"));
const linkTokenFactory = new LinkTokenFactory_1.LinkTokenFactory();
const ensRegistryFactory = new ENSRegistryFactory_1.ENSRegistryFactory();
const oracleFactory = new OracleFactory_1.OracleFactory();
const publicResolverFacotory = new PublicResolverFactory_1.PublicResolverFactory();
const updatableConsumerFactory = new UpdatableConsumerFactory_1.UpdatableConsumerFactory();
const provider = new ethers_1.ethers.providers.Web3Provider(ganache_core_1.default.provider());
let roles;
beforeAll(async () => {
    const rolesAndPersonas = await h.initializeRolesAndPersonas(provider);
    roles = rolesAndPersonas.roles;
});
describe('UpdatableConsumer', () => {
    // https://github.com/ethers-io/ethers-ens/blob/master/src.ts/index.ts#L631
    const ensRoot = ethers_1.ethers.utils.namehash('');
    const tld = 'cltest';
    const tldSubnode = ethers_1.ethers.utils.namehash(tld);
    const domain = 'chainlink';
    const domainNode = ethers_1.ethers.utils.namehash(`${domain}.${tld}`);
    const tokenSubdomain = 'link';
    const tokenSubnode = ethers_1.ethers.utils.namehash(`${tokenSubdomain}.${domain}.${tld}`);
    const oracleSubdomain = 'oracle';
    const oracleSubnode = ethers_1.ethers.utils.namehash(`${oracleSubdomain}.${domain}.${tld}`);
    const specId = ethers_1.ethers.utils.formatBytes32String('someSpecID');
    const newOracleAddress = '0xf000000000000000000000000000000000000ba7';
    let ens;
    let ensResolver;
    let link;
    let oc;
    let uc;
    const deployment = h.useSnapshot(provider, async () => {
        link = await linkTokenFactory.connect(roles.defaultAccount).deploy();
        oc = await oracleFactory.connect(roles.oracleNode).deploy(link.address);
        ens = await ensRegistryFactory.connect(roles.defaultAccount).deploy();
        ensResolver = await publicResolverFacotory
            .connect(roles.defaultAccount)
            .deploy(ens.address);
        const ensOracleNode = ens.connect(roles.oracleNode);
        const ensResolverOracleNode = ensResolver.connect(roles.oracleNode);
        // register tld
        await ens.setSubnodeOwner(ensRoot, h.keccak(ethers_1.ethers.utils.toUtf8Bytes(tld)), roles.defaultAccount.address);
        // register domain
        await ens.setSubnodeOwner(tldSubnode, h.keccak(ethers_1.ethers.utils.toUtf8Bytes(domain)), roles.oracleNode.address);
        await ensOracleNode.setResolver(domainNode, ensResolver.address);
        // register token subdomain to point to token contract
        await ensOracleNode.setSubnodeOwner(domainNode, h.keccak(ethers_1.ethers.utils.toUtf8Bytes(tokenSubdomain)), roles.oracleNode.address);
        await ensOracleNode.setResolver(tokenSubnode, ensResolver.address);
        await ensResolverOracleNode.setAddr(tokenSubnode, link.address);
        // register oracle subdomain to point to oracle contract
        await ensOracleNode.setSubnodeOwner(domainNode, h.keccak(ethers_1.ethers.utils.toUtf8Bytes(oracleSubdomain)), roles.oracleNode.address);
        await ensOracleNode.setResolver(oracleSubnode, ensResolver.address);
        await ensResolverOracleNode.setAddr(oracleSubnode, oc.address);
        // deploy updatable consumer contract
        uc = await updatableConsumerFactory
            .connect(roles.defaultAccount)
            .deploy(specId, ens.address, domainNode);
    });
    beforeEach(async () => {
        await deployment();
    });
    describe('constructor', () => {
        it('pulls the token contract address from the resolver', async () => {
            chai_1.assert.equal(link.address, await uc.getChainlinkToken());
        });
        it('pulls the oracle contract address from the resolver', async () => {
            chai_1.assert.equal(oc.address, await uc.getOracle());
        });
    });
    describe('#updateOracle', () => {
        describe('when the ENS resolver has been updated', () => {
            beforeEach(async () => {
                await ensResolver
                    .connect(roles.oracleNode)
                    .setAddr(oracleSubnode, newOracleAddress);
            });
            it("updates the contract's oracle address", async () => {
                await uc.updateOracle();
                chai_1.assert.equal(newOracleAddress.toLowerCase(), (await uc.getOracle()).toLowerCase());
            });
        });
        describe('when the ENS resolver has not been updated', () => {
            it('keeps the same oracle address', async () => {
                await uc.updateOracle();
                chai_1.assert.equal(oc.address, await uc.getOracle());
            });
        });
    });
    describe('#fulfillOracleRequest', () => {
        const response = ethers_1.ethers.utils.formatBytes32String('1,000,000.00');
        const currency = 'USD';
        const paymentAmount = h.toWei('1');
        let request;
        beforeEach(async () => {
            await link.transfer(uc.address, paymentAmount);
            const tx = await uc.requestEthereumPrice(h.toHex(ethers_1.ethers.utils.toUtf8Bytes(currency)));
            const receipt = await tx.wait();
            request = h.decodeRunRequest(receipt.logs[3]);
        });
        it('records the data given to it by the oracle', async () => {
            await h.fulfillOracleRequest(oc, request, response);
            const currentPrice = await uc.currentPrice();
            chai_1.assert.equal(currentPrice, response);
        });
        describe('when the oracle address is updated before a request is fulfilled', () => {
            beforeEach(async () => {
                await ensResolver
                    .connect(roles.oracleNode)
                    .setAddr(oracleSubnode, newOracleAddress);
                await uc.updateOracle();
                chai_1.assert.equal(newOracleAddress.toLowerCase(), (await uc.getOracle()).toLowerCase());
            });
            it('records the data given to it by the old oracle contract', async () => {
                await h.fulfillOracleRequest(oc, request, response);
                const currentPrice = await uc.currentPrice();
                chai_1.assert.equal(currentPrice, response);
            });
            it('does not accept responses from the new oracle for the old requests', async () => {
                await h.assertActionThrows(async () => {
                    await uc
                        .connect(roles.oracleNode)
                        .fulfill(request.id, h.toHex(response));
                });
                const currentPrice = await uc.currentPrice();
                chai_1.assert.equal(ethers_1.ethers.utils.parseBytes32String(currentPrice), '');
            });
            it('still allows funds to be withdrawn from the oracle', async () => {
                await h.increaseTime5Minutes(provider);
                matchersV2_1.assertBigNum(0, await link.balanceOf(uc.address), 'Initial balance should be 0');
                await uc.cancelRequest(request.id, request.payment, request.callbackFunc, request.expiration);
                matchersV2_1.assertBigNum(paymentAmount, await link.balanceOf(uc.address), 'Oracle should have been repaid on cancellation.');
            });
        });
    });
});
//# sourceMappingURL=UpdatableConsumer.test.js.map