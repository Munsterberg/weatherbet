"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const bn_js_1 = require("bn.js");
const cbor_1 = __importDefault(require("cbor"));
const abi = __importStar(require("ethereumjs-abi"));
const util = __importStar(require("ethereumjs-util"));
const truffle_contract_1 = __importDefault(require("truffle-contract"));
const LinkToken_json_1 = __importDefault(require("./LinkToken.json"));
const matchers_1 = require("./matchers");
// https://github.com/ethereum/web3.js/issues/1119#issuecomment-394217563
web3.providers.HttpProvider.prototype.sendAsync =
    web3.providers.HttpProvider.prototype.send;
exports.eth = web3.eth;
const INVALIDVALUE = {
    // If you got this value, you probably tried to use one of the variables below
    // before they were initialized. Do any test initialization which requires
    // them in a callback passed to Mocha's `before` or `beforeEach`.
    // https://mochajs.org/#asynchronous-hooks
    unitializedValueProbablyShouldUseVaribleInMochaBeforeCallback: null,
};
_a = Array(1000).fill(INVALIDVALUE), exports.accounts = _a[0], exports.defaultAccount = _a[1], exports.oracleNode1 = _a[2], exports.oracleNode2 = _a[3], exports.oracleNode3 = _a[4], exports.stranger = _a[5], exports.consumer = _a[6], exports.oracleNode = _a[7];
exports.personas = {};
before(async function queryEthClientForConstants() {
    exports.accounts = await exports.eth.getAccounts();
    [
        exports.defaultAccount,
        exports.oracleNode1,
        exports.oracleNode2,
        exports.oracleNode3,
        exports.stranger,
        exports.consumer,
    ] = exports.accounts.slice(0, 6);
    exports.oracleNode = exports.oracleNode1;
    // allow personas instead of roles
    exports.personas.Default = exports.defaultAccount;
    exports.personas.Neil = exports.oracleNode1;
    exports.personas.Ned = exports.oracleNode2;
    exports.personas.Nelly = exports.oracleNode3;
    exports.personas.Carol = exports.consumer;
    exports.personas.Eddy = exports.stranger;
});
const bNToStringOrIdentity = (a) => (bn_js_1.BN.isBN(a) ? a.toString() : a);
exports.BNtoUint8Array = (n) => Uint8Array.from(new bn_js_1.BN(n).toArray('be', 32));
// Deal with transfer amount type truffle doesn't currently handle. (BN)
exports.wrappedERC20 = (contract) => ({
    ...contract,
    transfer: async (address, amount) => contract.transfer(address, bNToStringOrIdentity(amount)),
    transferAndCall: async (address, amount, payload, options) => contract.transferAndCall(address, bNToStringOrIdentity(amount), payload, options),
});
exports.linkContract = async (account) => {
    account = account || exports.defaultAccount;
    const receipt = await web3.eth.sendTransaction({
        data: LinkToken_json_1.default.bytecode,
        from: account,
        gasLimit: 2000000,
    });
    const contract = truffle_contract_1.default({ abi: LinkToken_json_1.default.abi });
    contract.setProvider(web3.currentProvider);
    contract.defaults({
        from: account,
        gas: 3500000,
        gasPrice: 10000000000,
    });
    return exports.wrappedERC20(await contract.at(receipt.contractAddress));
};
exports.bigNum = web3.utils.toBN;
matchers_1.assertBigNum(exports.bigNum('1'), exports.bigNum(1), 'Different representations should give same BNs');
// toWei(n) is n * 10**18, as a BN.
exports.toWei = (num) => exports.bigNum(web3.utils.toWei(exports.bigNum(num)));
matchers_1.assertBigNum(exports.toWei('1'), exports.toWei(1), 'Different representations should give same BNs');
exports.toUtf8 = web3.utils.toUtf8;
exports.keccak = web3.utils.sha3;
const hexRegExp = /^(0[xX])?[0-9a-fA-F]+$/;
const isHex = hexRegExp.test.bind(hexRegExp);
exports.hexToInt = (str) => exports.bigNum(str).toNumber();
exports.toHexWithoutPrefix = (arg) => {
    if (arg instanceof Buffer || arg instanceof bn_js_1.BN) {
        return arg.toString('hex');
    }
    else if (arg instanceof Uint8Array) {
        return Array.prototype.reduce.call(arg, (a, v) => a + v.toString('16').padStart(2, '0'), '');
    }
    else if (Number(arg) === arg) {
        return arg.toString(16).padStart(64, '0');
    }
    else {
        assert.equal(typeof arg, 'string', `Don't know how to convert ${arg} to hex`);
        return Buffer.from(arg, 'ascii').toString('hex');
    }
};
exports.toHex = (value) => {
    return Ox(exports.toHexWithoutPrefix(value));
};
function Ox(value) {
    return value.slice(0, 2) !== '0x' ? `0x${value}` : value;
}
exports.Ox = Ox;
// True if h is a standard representation of a byte array, false otherwise
exports.isByteRepresentation = (h) => {
    return h instanceof Buffer || h instanceof bn_js_1.BN || h instanceof Uint8Array;
};
exports.getEvents = (contract) => new Promise((resolve, reject) => contract
    .getPastEvents('allEvents', { fromBlock: 1 }) // https://ethereum.stackexchange.com/questions/71307/mycontract-getpasteventsallevents-returns-empty-array
    .then((events) => resolve(events))
    .catch((error) => reject(error)));
exports.getLatestEvent = async (contract) => {
    const events = await exports.getEvents(contract);
    return events[events.length - 1];
};
// link param must be from linkContract(), if amount is a BN
exports.requestDataFrom = (oc, link, amount, args, options) => {
    if (!options) {
        options = { value: 0 };
    }
    return link.transferAndCall(oc.address, amount, args, options);
};
// ABI specification for the given method on the given contract
exports.getMethod = (contract, methodName) => {
    const methodABIs = contract.abi.filter(({ name: attrName }) => attrName == methodName);
    const fqName = `${contract.contractName}.${methodName}: ${methodABIs}`;
    assert.equal(methodABIs.length, 1, `No method ${fqName}, or ambiguous`);
    return methodABIs[0];
};
exports.functionSelector = web3.eth.abi.encodeFunctionSignature;
exports.functionSelectorFromAbi = (contract, name) => exports.functionSelector(exports.getMethod(contract, name));
exports.assertActionThrows = (action, messageContains) => Promise.resolve()
    .then(action)
    .catch(error => {
    assert(error, 'Expected an error to be raised');
    assert(error.message, 'Expected an error to be raised');
    return error.message;
})
    .then(errorMessage => {
    assert(errorMessage, 'Expected an error to be raised');
    const invalidOpcode = errorMessage.includes('invalid opcode');
    const reverted = errorMessage.includes('VM Exception while processing transaction: revert');
    assert(invalidOpcode || reverted, 'expected following error message to include "invalid JUMP" or ' +
        `"revert": "${errorMessage}"`);
    assert(!messageContains || messageContains.test(errorMessage), `expected error message to contain ${messageContains}: ${errorMessage}`);
    // see https://github.com/ethereumjs/testrpc/issues/39
    // for why the "invalid JUMP" is the throw related error when using TestRPC
});
exports.checkPublicABI = (contract, expectedPublic) => {
    const actualPublic = [];
    for (const method of contract.abi) {
        if (method.type === 'function') {
            actualPublic.push(method.name);
        }
    }
    for (const method of actualPublic) {
        const index = expectedPublic.indexOf(method);
        assert.isAtLeast(index, 0, `#${method} is NOT expected to be public`);
    }
    for (const method of expectedPublic) {
        const index = actualPublic.indexOf(method);
        assert.isAtLeast(index, 0, `#${method} is expected to be public`);
    }
};
exports.decodeRunABI = (log) => {
    const runABI = util.toBuffer(log.data);
    const types = ['bytes32', 'address', 'bytes4', 'bytes'];
    return abi.rawDecode(types, runABI);
};
const startMapBuffer = Buffer.from([0xbf]);
const endMapBuffer = Buffer.from([0xff]);
exports.decodeRunRequest = (log) => {
    const runABI = util.toBuffer(log.data);
    const types = [
        'address',
        'bytes32',
        'uint256',
        'address',
        'bytes4',
        'uint256',
        'uint256',
        'bytes',
    ];
    const [requester, requestId, payment, callbackAddress, callbackFunc, expiration, version, data,] = abi.rawDecode(types, runABI);
    return {
        callbackAddr: Ox(callbackAddress),
        callbackFunc,
        data: autoAddMapDelimiters(data),
        dataVersion: version,
        expiration,
        id: requestId,
        jobId: log.topics[1],
        payment,
        requester: Ox(requester),
        topic: log.topics[0],
    };
};
function autoAddMapDelimiters(data) {
    let buffer = data;
    if (buffer[0] >> 5 !== 5) {
        buffer = Buffer.concat([startMapBuffer, buffer, endMapBuffer], buffer.length + 2);
    }
    return buffer;
}
exports.decodeDietCBOR = (data) => {
    return cbor_1.default.decodeFirstSync(autoAddMapDelimiters(data));
};
exports.runRequestId = (log) => {
    const { requestId } = exports.decodeRunRequest(log);
    return requestId;
};
exports.requestDataBytes = (specId, to, fHash, nonce, data) => {
    const types = [
        'address',
        'uint256',
        'bytes32',
        'address',
        'bytes4',
        'uint256',
        'uint256',
        'bytes',
    ];
    const values = [0, 0, specId, to, fHash, nonce, 1, data];
    const encoded = abiEncode(types, values);
    const funcSelector = exports.functionSelector('oracleRequest(address,uint256,bytes32,address,bytes4,uint256,uint256,bytes)');
    return funcSelector + encoded;
};
function abiEncode(types, values) {
    return abi.rawEncode(types, values).toString('hex');
}
exports.abiEncode = abiEncode;
exports.newUint8ArrayFromStr = (str) => {
    const codePoints = Array.prototype.map.call(str, (c) => c.charCodeAt(0));
    return Uint8Array.from(codePoints);
};
// newUint8ArrayFromHex returns count bytes from hex string. They are padded at
// the end to have `count` bytes
exports.newUint8ArrayFromHex = (str, count) => {
    assert(isHex(str), `${str} is not a hexadecimal value`);
    const hexCount = 2 * count + 2;
    const hexStr = Ox(str);
    assert(hexStr.length <= hexCount, `${str} won't fit in ${count} bytes`);
    return Uint8Array.from(web3.utils.hexToBytes(hexStr.padEnd(hexCount, '0')));
};
// newUint8ArrayFromDecimal returns count bytes from a decimal number. They are
// padded at the start to have `count` bytes
exports.newUint8ArrayFromDecimal = (str, count) => {
    assert(/^[0-9]+$/.test(str), `${str} is not a decimal value.`);
    const hexCount = 2 * count;
    const hexStr = new bn_js_1.BN(str, 10).toString(16).padStart(hexCount, '0');
    assert(hexStr.length <= hexCount, `${str} won't fit in ${count} bytes`);
    return Uint8Array.from(web3.utils.hexToBytes(Ox(hexStr)));
};
// newSignature returns a signature object with v, r, and s broken up
exports.newSignature = (str) => {
    const oracleSignature = exports.newUint8ArrayFromHex(str, 65);
    let v = oracleSignature[64];
    if (v < 27) {
        v += 27;
    }
    return {
        full: oracleSignature,
        r: oracleSignature.slice(0, 32),
        s: oracleSignature.slice(32, 64),
        v,
    };
};
/**
 * @param str hexadecimal/decimal representation of integer. 0x must prefix hex.
 * @returns 32-byte representation of number. If hexadecimal, zero-padded on
 *          the right. If decimal, zero-padded on the left.
 * @todo (alx): Split this into more specific and explicit functions.
 */
exports.newHash = (str) => (/^0[xX]/.test(str) ? exports.newUint8ArrayFromHex : exports.newUint8ArrayFromDecimal)(str, 32);
// newAddress returns a 20-byte Uint8Array for representing an address
exports.newAddress = (str) => {
    return exports.newUint8ArrayFromHex(str, 20);
};
exports.newSelector = (str) => exports.newUint8ArrayFromHex(str, 4);
exports.toBuffer = (uint8a) => Buffer.from(uint8a);
exports.concatUint8Arrays = (...arrays) => Uint8Array.from(Buffer.concat(arrays.map(Buffer.from)));
exports.increaseTime5Minutes = async () => {
    await web3.currentProvider.send({
        id: 0,
        jsonrpc: '2.0',
        method: 'evm_increaseTime',
        params: [300],
    }, (error) => {
        if (error) {
            throw Error(`Error during helpers.increaseTime5Minutes! ${error}`);
        }
    });
};
exports.sendToEvm = async (evmMethod, ...params) => {
    await web3.currentProvider.sendAsync({
        id: 0,
        jsonrpc: '2.0',
        method: evmMethod,
        params: [...params],
    }, (error) => {
        if (error) {
            throw Error(`Error during ${evmMethod}! ${error}`);
        }
    });
};
exports.mineBlocks = async (blocks) => {
    for (let i = 0; i < blocks; i++) {
        await exports.sendToEvm('evm_mine');
    }
};
exports.createTxData = (selector, types, values) => {
    const funcSelector = exports.functionSelector(selector);
    const encoded = abiEncode([...types], [...values]);
    return funcSelector + encoded;
};
exports.generateSAID = (sa) => {
    const serviceAgreementIDInput = exports.concatUint8Arrays(exports.BNtoUint8Array(sa.payment), exports.BNtoUint8Array(sa.expiration), exports.BNtoUint8Array(sa.endAt), 
    // Each address in this list is padded to a uint256, despite being a uint160
    ...sa.oracles.map(pad0xHexTo256Bit).map(exports.newHash), exports.newHash(sa.requestDigest), exports.newAddress(sa.aggregator), exports.newSelector(sa.aggInitiateJobSelector), exports.newSelector(sa.aggFulfillSelector));
    const serviceAgreementIDInputDigest = util.keccak(exports.toHex(serviceAgreementIDInput));
    return exports.newHash(exports.toHex(serviceAgreementIDInputDigest));
};
exports.recoverPersonalSignature = (message, signature) => {
    const personalSignPrefix = exports.newUint8ArrayFromStr('\x19Ethereum Signed Message:\n');
    const personalSignMessage = Uint8Array.from(exports.concatUint8Arrays(personalSignPrefix, exports.newUint8ArrayFromStr(message.length.toString()), message));
    const digest = util.keccak(exports.toBuffer(personalSignMessage));
    const requestDigestPubKey = util.ecrecover(digest, signature.v, Buffer.from(signature.r), Buffer.from(signature.s));
    return util.pubToAddress(requestDigestPubKey);
};
exports.personalSign = async (account, message) => {
    const eMsg = `Message ${message} is not a recognized representation of a ` +
        'byte array. (Can be Buffer, BigNumber, Uint8Array, 0x-prepended ' +
        'hexadecimal string.)';
    assert(exports.isByteRepresentation(message), eMsg);
    return exports.newSignature(await web3.eth.sign(exports.toHex(message), account));
};
exports.executeServiceAgreementBytes = (sAID, callbackAddr, callbackFunctionId, nonce, data) => {
    const types = [
        'address',
        'uint256',
        'bytes32',
        'address',
        'bytes4',
        'uint256',
        'uint256',
        'bytes',
    ];
    const values = [0, 0, sAID, callbackAddr, callbackFunctionId, nonce, 1, data];
    const encoded = abiEncode(types, values);
    const funcSelector = exports.functionSelector('oracleRequest(address,uint256,bytes32,address,bytes4,uint256,uint256,bytes)');
    return funcSelector + encoded;
};
exports.depositFundsBytes = (to, amount) => {
    const types = ['address', 'uint256'];
    const values = [to, amount];
    const encoded = abiEncode(types, values);
    const funcSelector = exports.functionSelector('depositFunds(address,uint256)');
    return funcSelector + encoded;
};
// Convenience functions for constructing hexadecimal representations of
// binary serializations.export const padHexTo256Bit = (s: string): string => s.padStart(64, '0')
exports.strip0x = (s) => /^0[xX]/.test(s) ? s.slice(2) : s;
exports.padHexTo256Bit = (s) => s.padStart(64, '0');
function pad0xHexTo256Bit(s) {
    return Ox(exports.padHexTo256Bit(exports.strip0x(s)));
}
exports.pad0xHexTo256Bit = pad0xHexTo256Bit;
exports.padNumTo256Bit = (n) => exports.padHexTo256Bit(n.toString(16));
exports.constructStructArgs = (fieldNames, values) => {
    assert.equal(fieldNames.length, values.length);
    const args = [];
    for (let i = 0; i < fieldNames.length; i++) {
        args[i] = values[i];
        args[fieldNames[i]] = values[i];
    }
    return args;
};
// ABI specification for the given argument of the given contract method
const getMethodArg = (contract, methodName, argName) => {
    const fqName = `${contract.contractName}.${methodName}`;
    const methodABI = exports.getMethod(contract, methodName);
    let eMsg = `${fqName} is not a method: ${methodABI}`;
    assert.equal(methodABI.type, 'function', eMsg);
    const argMatches = methodABI.inputs.filter((a) => a.name == argName);
    eMsg = `${fqName} has no argument ${argName}, or name is ambiguous`;
    assert.equal(argMatches.length, 1, eMsg);
    return argMatches[0];
};
// Struct as mapping => tuple representation of struct, for use in truffle call
//
// TODO(alx): This does not deal with nested structs. It may be possible to do
// that by making an AbiCoder with a custom CoerceFunc which, given a tuple
// type, checks whether the input value is a map or a sequence, and if a map,
// converts it to a sequence as I'm doing here.
exports.structAsTuple = (struct, contract, methodName, argName) => {
    const abi = getMethodArg(contract, methodName, argName);
    const eMsg = `${contract.contractName}.${methodName}'s argument ${argName} ` +
        `is not a struct: ${abi}`;
    assert.equal(abi.type, 'tuple', eMsg);
    return { abi, struct: abi.components.map(({ name }) => struct[name]) };
};
exports.initiateServiceAgreementArgs = (coordinator, serviceAgreement) => {
    const signatures = {
        vs: serviceAgreement.oracleSignatures.map(os => os.v),
        rs: serviceAgreement.oracleSignatures.map(os => os.r),
        ss: serviceAgreement.oracleSignatures.map(os => os.s),
    };
    const tup = (s, n) => exports.structAsTuple(s, coordinator, 'initiateServiceAgreement', n).struct;
    return [tup(serviceAgreement, '_agreement'), tup(signatures, '_signatures')];
};
// Call coordinator contract to initiate the specified service agreement, and
// get the return value
exports.initiateServiceAgreementCall = async (coordinator, serviceAgreement) => await coordinator.initiateServiceAgreement.call(...exports.initiateServiceAgreementArgs(coordinator, serviceAgreement));
/** Call coordinator contract to initiate the specified service agreement. */
exports.initiateServiceAgreement = async (coordinator, serviceAgreement) => coordinator.initiateServiceAgreement(...exports.initiateServiceAgreementArgs(coordinator, serviceAgreement));
/** Check that the given service agreement was stored at the correct location */
exports.checkServiceAgreementPresent = async (coordinator, serviceAgreement) => {
    const sa = await coordinator.serviceAgreements.call(serviceAgreement.id);
    matchers_1.assertBigNum(sa[0], exports.bigNum(serviceAgreement.payment), 'expected payment');
    matchers_1.assertBigNum(sa[1], exports.bigNum(serviceAgreement.expiration), 'expected expiration');
    matchers_1.assertBigNum(sa[2], exports.bigNum(serviceAgreement.endAt), 'expected endAt date');
    assert.equal(sa[3], serviceAgreement.requestDigest, 'expected requestDigest');
};
// Check that all values for the struct at this SAID have default values. I.e.
// nothing was changed due to invalid request
exports.checkServiceAgreementAbsent = async (coordinator, serviceAgreementID) => {
    const sa = await coordinator.serviceAgreements.call(exports.toHex(serviceAgreementID).slice(0, 66));
    matchers_1.assertBigNum(sa[0], exports.bigNum(0), 'service agreement is not absent');
    matchers_1.assertBigNum(sa[1], exports.bigNum(0), 'service agreement is not absent');
    matchers_1.assertBigNum(sa[2], exports.bigNum(0), 'service agreement is not absent');
    assert.equal(sa[3], '0x0000000000000000000000000000000000000000000000000000000000000000');
};
exports.newServiceAgreement = async (params) => {
    const agreement = {};
    params = params || {};
    agreement.payment = params.payment || new bn_js_1.BN('1000000000000000000', 10);
    agreement.expiration = params.expiration || new bn_js_1.BN(300);
    agreement.endAt = params.endAt || sixMonthsFromNow();
    agreement.oracles = params.oracles || [exports.oracleNode];
    agreement.oracleSignatures = [];
    agreement.requestDigest =
        params.requestDigest ||
            '0xbadc0de5badc0de5badc0de5badc0de5badc0de5badc0de5badc0de5badc0de5';
    agreement.aggregator =
        params.aggregator || '0x3141592653589793238462643383279502884197';
    agreement.aggInitiateJobSelector =
        params.aggInitiateJobSelector || '0x12345678';
    agreement.aggFulfillSelector = params.aggFulfillSelector || '0x87654321';
    const sAID = exports.generateSAID(agreement);
    agreement.id = exports.toHex(sAID);
    for (let i = 0; i < agreement.oracles.length; i++) {
        const oracle = agreement.oracles[i];
        const oracleSignature = await exports.personalSign(oracle, sAID);
        const requestDigestAddr = exports.recoverPersonalSignature(sAID, oracleSignature);
        assert.equal(oracle.toLowerCase(), exports.toHex(requestDigestAddr));
        agreement.oracleSignatures[i] = oracleSignature;
    }
    return agreement;
};
function sixMonthsFromNow() {
    return new bn_js_1.BN(Math.round(Date.now() / 1000.0) + 6 * 30 * 24 * 60 * 60);
}
exports.sixMonthsFromNow = sixMonthsFromNow;
exports.fulfillOracleRequest = async (oracle, request, response, options) => {
    if (!options) {
        options = { value: 0 };
    }
    return oracle.fulfillOracleRequest(request.id, request.payment, request.callbackAddr, request.callbackFunc, request.expiration, exports.toHex(response), options);
};
exports.cancelOracleRequest = async (oracle, request, options) => {
    if (!options) {
        options = { value: 0 };
    }
    return oracle.cancelOracleRequest(request.id, request.payment, request.callbackFunc, request.expiration, options);
};
exports.hexPadUint256 = (n) => n.toJSON().padStart(64, '0');
exports.encodeUint256 = (int) => exports.hexPadUint256(new bn_js_1.BN(int));
exports.encodeInt256 = (int) => exports.hexPadUint256(new bn_js_1.BN(int).toTwos(256));
exports.encodeAddress = (a) => {
    assert(Ox(a).length <= 40, `${a} is too long to be an address`);
    return Ox(exports.strip0x(a).padStart(40, '0'));
};
//# sourceMappingURL=helpers.js.map